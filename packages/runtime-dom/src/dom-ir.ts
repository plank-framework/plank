/**
 * @fileoverview DOM IR execution for Plank runtime
 * Executes DOM operation IR generated by the compiler
 */

import { type Effect, effect, type Signal } from '@plank/runtime-core';
import { unbindElement } from './bindings.js';

export interface DOMOperation {
  type:
    | 'createElement'
    | 'createTextNode'
    | 'appendChild'
    | 'removeChild'
    | 'setAttribute'
    | 'removeAttribute'
    | 'setProperty'
    | 'addEventListener'
    | 'removeEventListener';
  tag?: string;
  text?: string;
  attributes?: Record<string, string>;
  property?: string;
  value?: unknown;
  event?: string;
  handler?: (...args: unknown[]) => void;
  parent?: Element;
  child?: Element | Text;
}

export interface DOMExecutionContext {
  container: Element;
  signals: Map<string, Signal<unknown>>;
  effects: Set<Effect>;
}

/**
 * Execute DOM operations from IR
 */
export function executeDOMIR(operations: DOMOperation[], _context: DOMExecutionContext): void {
  for (const operation of operations) {
    try {
      executeOperation(operation, _context);
    } catch (error) {
      console.error('Failed to execute DOM operation:', operation, error);
    }
  }
}

/**
 * Execute createElement operation
 */
function executeCreateElement(operation: DOMOperation): void {
  if (!operation.tag) {
    throw new Error('createElement operation requires tag');
  }
  const element = document.createElement(operation.tag);

  // Set attributes
  if (operation.attributes) {
    for (const [name, value] of Object.entries(operation.attributes)) {
      element.setAttribute(name, value);
    }
  }

  // Store element reference for later operations
  (operation as DOMOperation & { element: Element }).element = element;
}

/**
 * Execute createTextNode operation
 */
function executeCreateTextNode(operation: DOMOperation): void {
  if (operation.text === undefined) {
    throw new Error('createTextNode operation requires text');
  }
  const textNode = document.createTextNode(operation.text);
  (operation as DOMOperation & { textNode: Text }).textNode = textNode;
}

/**
 * Execute appendChild operation
 */
function executeAppendChild(operation: DOMOperation): void {
  if (!operation.parent || !operation.child) {
    throw new Error('appendChild operation requires parent and child');
  }
  operation.parent.appendChild(operation.child);
}

/**
 * Execute removeChild operation
 */
function executeRemoveChild(operation: DOMOperation): void {
  if (!operation.parent || !operation.child) {
    throw new Error('removeChild operation requires parent and child');
  }
  if (operation.parent.contains(operation.child)) {
    operation.parent.removeChild(operation.child);
  }
}

/**
 * Execute setAttribute operation
 */
function executeSetAttribute(operation: DOMOperation): void {
  if (!operation.parent || !operation.property || operation.value === undefined) {
    throw new Error('setAttribute operation requires parent, property, and value');
  }
  operation.parent.setAttribute(operation.property, String(operation.value));
}

/**
 * Execute removeAttribute operation
 */
function executeRemoveAttribute(operation: DOMOperation): void {
  if (!operation.parent || !operation.property) {
    throw new Error('removeAttribute operation requires parent and property');
  }
  operation.parent.removeAttribute(operation.property);
}

/**
 * Execute setProperty operation
 */
function executeSetProperty(operation: DOMOperation): void {
  if (!operation.parent || !operation.property || operation.value === undefined) {
    throw new Error('setProperty operation requires parent, property, and value');
  }
  try {
    Reflect.set(operation.parent, operation.property, operation.value);
  } catch (error) {
    console.warn(`Failed to set property "${operation.property}":`, error);
  }
}

/**
 * Execute addEventListener operation
 */
function executeAddEventListener(operation: DOMOperation): void {
  if (!operation.parent || !operation.event || !operation.handler) {
    throw new Error('addEventListener operation requires parent, event, and handler');
  }
  operation.parent.addEventListener(operation.event, operation.handler);
}

/**
 * Execute removeEventListener operation
 */
function executeRemoveEventListener(operation: DOMOperation): void {
  if (!operation.parent || !operation.event || !operation.handler) {
    throw new Error('removeEventListener operation requires parent, event, and handler');
  }
  operation.parent.removeEventListener(operation.event, operation.handler);
}

/**
 * Execute a single DOM operation
 */
function executeOperation(operation: DOMOperation, _context: DOMExecutionContext): void {
  switch (operation.type) {
    case 'createElement':
      executeCreateElement(operation);
      break;
    case 'createTextNode':
      executeCreateTextNode(operation);
      break;
    case 'appendChild':
      executeAppendChild(operation);
      break;
    case 'removeChild':
      executeRemoveChild(operation);
      break;
    case 'setAttribute':
      executeSetAttribute(operation);
      break;
    case 'removeAttribute':
      executeRemoveAttribute(operation);
      break;
    case 'setProperty':
      executeSetProperty(operation);
      break;
    case 'addEventListener':
      executeAddEventListener(operation);
      break;
    case 'removeEventListener':
      executeRemoveEventListener(operation);
      break;
    default:
      console.warn(
        'Unknown DOM operation type:',
        (operation as DOMOperation & { type: string }).type
      );
  }
}

/**
 * Create a reactive DOM execution context
 */
export function createDOMExecutionContext(container: Element): DOMExecutionContext {
  return {
    container,
    signals: new Map(),
    effects: new Set(),
  };
}

/**
 * Clean up DOM execution context
 */
export function cleanupDOMExecutionContext(context: DOMExecutionContext): void {
  const { effects } = context;

  // Stop all effects
  for (const effectObj of effects) {
    if (effectObj && typeof effectObj.stop === 'function') {
      effectObj.stop();
    }
  }
  effects.clear();

  // Clear signals
  context.signals.clear();
}

/**
 * Create reactive binding effect for text content
 */
function createTextBinding(element: Element, signal: Signal<unknown>, target: string): Effect {
  return effect(() => {
    const value = signal();
    if (target === 'textContent') {
      element.textContent = String(value ?? '');
    } else if (target === 'innerHTML') {
      element.innerHTML = String(value ?? '');
    }
  });
}

/**
 * Create reactive binding effect for attributes
 */
function createAttributeBinding(element: Element, signal: Signal<unknown>, target: string): Effect {
  return effect(() => {
    const value = signal();
    if (value === null || value === undefined || value === '') {
      element.removeAttribute(target);
    } else {
      element.setAttribute(target, String(value));
    }
  });
}

/**
 * Create reactive binding effect for properties
 */
function createPropertyBinding(element: Element, signal: Signal<unknown>, target: string): Effect {
  return effect(() => {
    const value = signal();
    try {
      Reflect.set(element, target, value);
    } catch (error) {
      console.warn(`Failed to set property "${target}":`, error);
    }
  });
}

/**
 * Create reactive binding effect for classes
 */
function createClassBinding(element: Element, signal: Signal<unknown>, target: string): Effect {
  return effect(() => {
    const value = signal();
    if (value) {
      element.classList.add(target);
    } else {
      element.classList.remove(target);
    }
  });
}

/**
 * Create reactive binding effect for styles
 */
function createStyleBinding(element: Element, signal: Signal<unknown>, target: string): Effect {
  return effect(() => {
    const value = signal();
    try {
      Reflect.set((element as HTMLElement).style, target, String(value ?? ''));
    } catch (error) {
      console.warn(`Failed to set style "${target}":`, error);
    }
  });
}

/**
 * Execute DOM IR with reactive bindings
 */
export function executeReactiveDOMIR(
  operations: DOMOperation[],
  context: DOMExecutionContext,
  bindings: Array<{
    element: Element;
    signal: Signal<unknown>;
    type: 'text' | 'attribute' | 'property' | 'class' | 'style';
    target: string;
  }>
): void {
  // Execute static DOM operations first
  executeDOMIR(operations, context);

  // Set up reactive bindings
  for (const binding of bindings) {
    const { element, signal, type, target } = binding;

    let effectObj: Effect;
    switch (type) {
      case 'text':
        effectObj = createTextBinding(element, signal, target);
        break;
      case 'attribute':
        effectObj = createAttributeBinding(element, signal, target);
        break;
      case 'property':
        effectObj = createPropertyBinding(element, signal, target);
        break;
      case 'class':
        effectObj = createClassBinding(element, signal, target);
        break;
      case 'style':
        effectObj = createStyleBinding(element, signal, target);
        break;
      default:
        console.warn(`Unknown binding type: ${type}`);
        continue;
    }

    context.effects.add(effectObj);
  }
}

/**
 * Create element from DOM operation
 */
export function createElementFromOperation(operation: DOMOperation): Element | Text | null {
  if (operation.type === 'createElement' && operation.tag) {
    const element = document.createElement(operation.tag);

    if (operation.attributes) {
      for (const [name, value] of Object.entries(operation.attributes)) {
        element.setAttribute(name, value);
      }
    }

    return element;
  }

  if (operation.type === 'createTextNode' && operation.text !== undefined) {
    return document.createTextNode(operation.text);
  }

  return null;
}

/**
 * Remove element and clean up bindings
 */
export function removeElement(element: Element): void {
  // Clean up bindings first
  unbindElement(element);

  // Remove from DOM
  if (element.parentNode) {
    element.parentNode.removeChild(element);
  }
}
